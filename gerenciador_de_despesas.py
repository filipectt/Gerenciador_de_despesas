# -*- coding: utf-8 -*-
"""Gerenciador_de_despesas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VDxmJ50qVFoH-gkAQz_P4Y3KzbclNJWI

## **GERENCIADOR DE DESPESAS**
"""

# @title
!pip install xlsxwriter

# @title
import pandas as pd
from datetime import datetime, timedelta
import io
from google.colab import files
import numpy as np

COLUNAS_MAP = {
    'nome do credor': 'Nome_Credor',
    'numero fatura': 'Numero_Fatura',
    'data do vencto': 'Data_Vencimento',
    'valor total': 'Valor',
}

def obter_dias_uteis_pagamento(data_base):
    dias_pagamento = []
    dias_semana_alvo = [0, 2, 4]
    data_inicio = data_base.replace(day=1)
    data_atual = data_inicio

    while data_atual.month == data_base.month:
        if data_atual.weekday() in dias_semana_alvo:
            dias_pagamento.append(data_atual.date())
        data_atual += timedelta(days=1)

    hoje = datetime.now().date()
    dias_pagamento = [d for d in dias_pagamento if d >= hoje]
    return dias_pagamento

def get_semana_do_mes(data):
    if not isinstance(data, datetime):
        data = datetime.combine(data, datetime.min.time())

    primeiro_dia_mes = data.replace(day=1)
    primeira_segunda = primeiro_dia_mes + timedelta(days=(7 - primeiro_dia_mes.weekday()) % 7)

    if data.date() < primeira_segunda.date():
        return 1

    return int(np.floor((data.day - primeira_segunda.day) / 7)) + 2

def gerenciar_pagamentos_mensal(df_dividas, disponibilidade_mensal, target_date, ano_fiscal):
    hoje = datetime.now().date()

    df_dividas.columns = df_dividas.columns.str.strip().str.lower()

    for col_original, col_nova in COLUNAS_MAP.items():
        if col_original in df_dividas.columns:
            df_dividas.rename(columns={col_original: col_nova}, inplace=True)

    df_dividas['Valor'] = (
        df_dividas['Valor']
        .astype(str)
        .str.replace('.', '', regex=False)
        .str.replace(',', '.', regex=False)
    )

    df_dividas['Valor'] = pd.to_numeric(df_dividas['Valor'], errors='coerce')
    df_dividas['Data_Vencimento'] = pd.to_datetime(
        df_dividas['Data_Vencimento'],
        errors='coerce',
        dayfirst=True
    ).dt.date

    df_dividas.dropna(
        subset=['Valor', 'Data_Vencimento', 'Nome_Credor', 'Numero_Fatura'],
        inplace=True
    )

    df_dividas = df_dividas[
        pd.to_datetime(df_dividas['Data_Vencimento']).dt.year == ano_fiscal
    ].copy()

    print(f"\nTotal de dívidas válidas encontradas após limpeza: {len(df_dividas)}")

    if df_dividas.empty:
        print(f"\nNenhuma dívida válida restante para processamento no ano de {ano_fiscal}.")
        return 0, 0, 0

    df_dividas['Status_Atraso'] = df_dividas['Data_Vencimento'].apply(
        lambda x: 1 if x < hoje else 0
    )

    df_dividas['Status_Juros'] = df_dividas['Status_Atraso'].apply(
        lambda x: 'VENCIDO (Sujeito a Juros)' if x == 1 else 'Em Dia'
    )

    df_dividas.sort_values(
        by=['Status_Atraso', 'Data_Vencimento', 'Valor'],
        ascending=[False, True, True],
        inplace=True
    )

    saldo_restante = disponibilidade_mensal
    pagamentos_selecionados = []
    df_dividas['Status_Pagamento'] = 'Pendente'
    df_dividas['Data_Agendada'] = pd.NaT

    print("\n" + "=" * 50)
    print(f"ANÁLISE E SELEÇÃO DE PAGAMENTOS (Ano: {ano_fiscal})")
    print("=" * 50)
    print(f"Disponibilidade Mensal: R$ {disponibilidade_mensal:,.2f}")

    for index, divida in df_dividas.iterrows():
        valor_divida = divida['Valor']
        status_atraso_str = "ATRASO" if divida['Status_Atraso'] == 1 else "EM DIA"

        if saldo_restante >= valor_divida:
            saldo_restante -= valor_divida
            df_dividas.loc[index, 'Status_Pagamento'] = 'Selecionado para Pagamento'
            pagamentos_selecionados.append(index)
            print(f"[PAGO] R$ {valor_divida:,.2f} | Vencimento: {divida['Data_Vencimento']} | Status: {status_atraso_str}")
        else:
            df_dividas.loc[index, 'Status_Pagamento'] = 'Pendente (Sem Saldo)'
            print(f"[IGNORADO] R$ {valor_divida:,.2f} | Vencimento: {divida['Data_Vencimento']} | Status: {status_atraso_str} | Saldo Insuficiente")

    df_pagar = df_dividas.loc[pagamentos_selecionados].copy()
    dias_agendamento = obter_dias_uteis_pagamento(target_date)

    if dias_agendamento:
        indice_dia = 0
        for index in df_pagar.index:
            df_dividas.loc[index, 'Data_Agendada'] = dias_agendamento[indice_dia]
            indice_dia = (indice_dia + 1) % len(dias_agendamento)

    total_pago = df_pagar['Valor'].sum()

    print("\n" + "=" * 50)
    print(f"RELATÓRIO DE AGENDA ({target_date.strftime('%m/%Y')})")
    print("=" * 50)
    print(f"Disponibilidade Inicial: R$ {disponibilidade_mensal:,.2f}")
    print(f"Total Selecionado: R$ {total_pago:,.2f}")
    print(f"Saldo Remanescente: R$ {saldo_restante:,.2f}")
    print("=" * 50)

    df_agendado_relatorio = df_dividas[
        df_dividas['Status_Pagamento'] == 'Selecionado para Pagamento'
    ].copy()

    df_agendado_relatorio.rename(columns={
        'Nome_Credor': 'nome do credor',
        'Numero_Fatura': 'numero da fatura',
        'Valor': 'valor a pagar',
        'Data_Vencimento': 'data vencimento original',
        'Status_Juros': 'status juros',
        'Data_Agendada': 'data agendada',
    }, inplace=True)

    df_agendado_relatorio['data agendada'] = pd.to_datetime(
        df_agendado_relatorio['data agendada']
    )
    df_agendado_relatorio['Semana'] = df_agendado_relatorio['data agendada'].apply(
        get_semana_do_mes
    )

    df_visualizacao = df_agendado_relatorio[
        [
            'data agendada',
            'nome do credor',
            'numero da fatura',
            'valor a pagar',
            'data vencimento original',
            'status juros',
            'Semana'
        ]
    ].copy()

    nome_saida = f'agenda_pagamentos_{target_date.strftime("%Y%m")}_Ano_{ano_fiscal}.xlsx'

    if not df_visualizacao.empty:
        with pd.ExcelWriter(
            nome_saida,
            engine='xlsxwriter',
            datetime_format='dd/mm/yyyy'
        ) as writer:

            df_resumo = pd.DataFrame({
                'Métrica': [
                    'Disponibilidade Inicial',
                    'Total Selecionado',
                    'Saldo Remanescente'
                ],
                'Valor (R$)': [
                    disponibilidade_mensal,
                    total_pago,
                    saldo_restante
                ]
            })

            df_resumo['Valor (R$)'] = df_resumo['Valor (R$)'].map(
                'R$ {:,.2f}'.format
            )
            df_resumo.to_excel(writer, sheet_name='RESUMO GERAL', index=False)

            for semana, df_semana in df_visualizacao.groupby('Semana'):
                df_semana.drop(columns=['Semana']).to_excel(
                    writer,
                    sheet_name=f'Semana {semana}',
                    index=False
                )

    print(f"\nAgenda de Pagamentos salva como: {nome_saida}")
    files.download(nome_saida)

    print("\nVISUALIZAÇÃO DA AGENDA")
    if not df_visualizacao.empty:
        print(df_visualizacao.drop(columns=['Semana']).to_string(index=False))

    return total_pago, disponibilidade_mensal, saldo_restante

if __name__ == "__main__":

    print("\nSISTEMA DE GESTÃO E AGENDAMENTO DE PAGAMENTOS")

    while True:
        ano_str = input("Digite o ANO FISCAL (Ex: 2025): ")
        try:
            ano_fiscal = int(ano_str)
            if 2000 <= ano_fiscal <= 2100:
                break
        except ValueError:
            pass

    while True:
        disponibilidade_str = input("Digite o valor disponível (Ex: 5000.00): R$ ")
        try:
            disponibilidade = float(disponibilidade_str.replace(',', '.'))
            if disponibilidade >= 0:
                break
        except ValueError:
            pass

    while True:
        mes_str = input("Digite o mês/ano para agendamento (Ex: 12/2025): ")
        try:
            target_date = datetime.strptime(f"01/{mes_str}", "%d/%m/%Y")
            break
        except ValueError:
            pass

    uploaded = files.upload()

    if uploaded:
        nome_arquivo = list(uploaded.keys())[0]
        conteudo_bytes = uploaded[nome_arquivo]

        tentativas = [
            ('utf-8', ','),
            ('latin-1', ','),
            ('cp1252', ','),
            ('latin-1', ';'),
            ('cp1252', ';')
        ]

        for encoding, sep in tentativas:
            try:
                df_temp = pd.read_csv(
                    io.BytesIO(conteudo_bytes),
                    encoding=encoding,
                    sep=sep,
                    engine='python'
                )

                if all(
                    col in df_temp.columns.str.lower()
                    for col in COLUNAS_MAP.keys()
                ):
                    gerenciar_pagamentos_mensal(
                        df_temp,
                        disponibilidade,
                        target_date,
                        ano_fiscal
                    )
                    break
            except Exception:
                continue